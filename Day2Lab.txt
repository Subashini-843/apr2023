Lab4 - Create two Structures
            2DPoint (X, Y)
            3DPoint (X, Y, Z)
       interface Modify {
            Add(int)
            }
       implement Modify for 2DPoint and 3DPoint 
       Ask user choise of 2D/3D and using interface invoke add(5) 
       
Lab3 - package main
      import "fmt"
      type Myinterface interface{
            Shift() 
      }
      type Point struct{
            X int
            Y int
      }
      func (pt Point) Shift(){
            fmt.Println("Shift invoked ..")
      }
      func main() {
            p1 := Point{10,10}
            fmt.Println(p1)
            var myinterface Myinterface
            myinterface = p1
            myinterface.Shift()
      }
Lab2 - panic/recover
      package main

      import "fmt"

      func main() {
            defer fmt.Println("in main defer line 1")
            fmt.Println("starting of main")
            test(4)
            fmt.Println("after test")
      }
      func test(i int) {
            defer func() {
                  if r := recover(); r != nil {
                        fmt.Println("Recovered in f", r)
                  }
            }()
            defer fmt.Println("Defer in g", i)
            if i > 3 {
                  fmt.Println("Panicking!")
                  panic(fmt.Sprintf("%v", i))
            }
            fmt.Println("Printing in g ", i)
            //	   g(i + 1)
      }

Lab1 - Day2/demo1/Lab1.go - closures
      package main
      import "fmt"

      func adder() func(int) int {
        sum := 0
        fmt.Println("adder function invoked ...")
        return func(x int) int {
          sum += x
          fmt.Println("in return function with ", x , " and current sum is " , sum)
          return sum
        }
      }
      func main(){
        fn1 := adder()
        fn1(10)
        fn1(11)

      }
